####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet

import json
import heapq

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        self.sequence_number = 0 
        self.link_state = {}
        self.lsdb = {}
        self.lsdb[self.addr] = {'sequence_number': self.sequence_number, 'link_state': self.link_state.copy()}
        self.forwarding_table = {} 
        self.forwarding_table[self.addr] = None 

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            end_port = packet.dst_addr
            if end_port in self.forwarding_table:
                out_port = self.forwarding_table[end_port]
                self.send(out_port, packet)
                return
        else:
            # Hint: this is a routing packet generated by your routing protocol
            src_addr = packet.src_addr
            sequence_number, link_state = json.loads(packet.content)
            # If the sequence number is higher and the received link state is different
            previous_link_state = self.lsdb.get(src_addr)
            if previous_link_state is None or sequence_number > self.lsdb[src_addr]['sequence_number']:
                #   update the local copy of the link state
                self.lsdb[src_addr] = {'sequence_number': sequence_number, 'link_state': link_state}
                #   update the forwarding table
                self.compute_forwarding_table()
                #   broadcast the packet to other neighbors
                for p, (nbr, _) in self.link_state.items():
                    if p != port:
                        content_str = json.dumps((sequence_number, link_state))
                        copy_packet = Packet(Packet.ROUTING, self.addr, nbr, content=content_str)
                        self.send(p, copy_packet)

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        self.link_state[port] = (endpoint, cost)
        self.sequence_number += 1
        self.lsdb[self.addr] = {
            'sequence_number': self.sequence_number,
            'link_state': self.link_state.copy() 
        }
        self.compute_forwarding_table()
        #   broadcast the new link state of this router to all neighbors
        self.broadcast_lsa()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        if port in self.link_state:
            del self.link_state[port]
            self.sequence_number += 1
            self.lsdb[self.addr] = {
                'sequence_number': self.sequence_number,
                'link_state': self.link_state.copy() 
            }
            self.compute_forwarding_table()
        #   broadcast the new link state of this router to all neighbors
            self.broadcast_lsa()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            self.sequence_number += 1
            self.broadcast_lsa()

    def broadcast_lsa(self):
        lsa_content = json.dumps((self.sequence_number, self.link_state.copy()))
        for port, (neighbor, _) in self.link_state.items():
            pkt = Packet(Packet.ROUTING, self.addr, neighbor, content=lsa_content)
            self.send(port, pkt)

    def compute_forwarding_table(self):
        #B1: xây đồ thị
        graph = {r: {} for r in self.lsdb}
        for r, data in self.lsdb.items():
            for _, (nbr, cost) in data['link_state'].items():
                graph[r][nbr] = cost
        #B2: chạy Dijkstra
        dist = {node: int('16') for node in graph}
        prev = {}
        dist[self.addr] = 0
        heap = [(0, self.addr)]
        while heap:
            d, u = heapq.heappop(heap)
            if d > dist[u]:
                continue
            for v, w in graph[u].items():
                alt = d + w
                if alt < dist[v]:
                    dist[v] = alt
                    prev[v] = u
                    heapq.heappush(heap, (alt, v))
        #B3: cập nhật bảng định tuyến
        self.forwarding_table.clear()
        self.forwarding_table = {self.addr: None}
        for dest in graph:
            if dest == self.addr or dest not in prev:
                continue
            # tìm next hop đầu tiên
            hop = dest
            while prev[hop] != self.addr:
                hop = prev[hop]
            # tìm port tương ứng với hop
            for port, (nbr, _) in self.link_state.items():
                if nbr == hop:
                    self.forwarding_table[dest] = port
                    break

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"
