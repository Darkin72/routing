####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet


class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        self.seq = 0 # so thu tu cho cac LSP cua router nay
        self.neighbor = {} # luu tru chi phi den hang xom
        self.neighbor_ports = {} # chuyen tu dia chi hang xom sang cong se ket noi
        self.db = {}
        self.db[self.addr] = {'seq': self.seq, 'neighbor': self.neighbor.copy()}

        self.forwarding_table = {} # tu dia chi cu the => cong ra


    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            dst = packet.dst_addr
            if dst == self.addr: # neu dich chinh la router nay thi return
                return

            out_port = self.forwarding_table.get(dst)
            if out_port is not None:
                self.send(out_port, packet)


        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors

            content = packet.content
            origin = content['origin'] #router goc gui lsp nay
            seq = content['seq']
            links = content['neighbors']

            if origin not in self.db or seq > self.db[origin]['seq']:
                self.db[origin] = {'seq': seq, 'neighbor': links.copy()}
                self._compute_routes()

                for nbr_addr, out_p in self.neighbor_ports.items():
                    if out_p != port:
                        new_pkt = packet.copy()
                        self.send(out_p, new_pkt)

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        self.neighbor[endpoint] = cost
        self.neighbor_ports[endpoint] = port

        self.seq += 1

        self.db[self.addr] = {'seq': self.seq, 'neighbor': self.neighbor.copy()}
        self._compute_routes()
        self._broadcast_lsp()

    def handle_remove_link(self, port):
        """Handle removed link."""
        removed_neighbor_addr = None

        for nbr, p in self.neighbor_ports.items():
            if p == port:
                removed_neighbor_addr = nbr
                break

        if removed_neighbor_addr is not None:
            del self.neighbor_ports[removed_neighbor_addr]
            del self.neighbor[removed_neighbor_addr]

            self.seq += 1
            self.db[self.addr] = {'seq': self.seq, 'neighbor': self.neighbor.copy()}

            self._compute_routes()
            self._broadcast_lsp()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            self._broadcast_lsp()


    def _broadcast_lsp(self):
        pkt_content = {
            'origin': self.addr,
            'seq': self.seq,
            'neighbor': self.neighbor.copy()
        }
        lsp_packet = Packet(Packet.ROUTING, self.addr, None, content=pkt_content)
        for nbr_addr, port in self.neighbor_ports.items():
            self.send(port, lsp_packet.copy())

    def _compute_routes(self):




    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"
