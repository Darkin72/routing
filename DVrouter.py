####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import json


class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.forwarding_table = {}  
        self.forwarding_table[addr] = None
        self.distance_vector = {}
        self.distance_vector[addr] = 0
        self.neighbors = {}
        self.debug = False

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dst_addr in self.forwarding_table:
                self.send(self.forwarding_table[packet.dst_addr], packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            if packet.src_addr not in self.neighbors:
                self.neighbors[packet.src_addr] = packet.content
            else:
                content_received = json.loads(packet.content)
            # If the received distance vector is different
                if (content_received != self.neighbors[packet.src_addr]) :
            #   update the local copy of the distance vector
                    self.neighbors[packet.src_addr] = content_received
            #   update the distance vector of this router
            #   update the forwarding table
                    cost_tmp = self.distance_vector[packet.src_addr]
                    for endpoint, cost in content_received.items():
                        if endpoint not in self.forwarding_table:
                            self.forwarding_table[endpoint] = self.forwarding_table[packet.src_addr]
                            self.distance_vector[endpoint] = cost_tmp + cost
                        else:
                            if cost_tmp + cost < self.distance_vector[endpoint] :
                                self.forwarding_table[endpoint] = self.forwarding_table[packet.src_addr]
                                self.distance_vector[endpoint] = cost_tmp + cost
            #   broadcast the distance vector of this router to neighbors
                    for endpoint, to_port in self.forwarding_table.items():
                        content = json.dumps(self.distance_vector)
                        self.send(to_port, Packet(Packet.ROUTING, self.addr, endpoint , content=content))

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        self.distance_vector[endpoint] = cost

        #   update the forwarding table
        self.forwarding_table[endpoint] = port

        #   broadcast the distance vector of this router to neighbors
        for endpoint, to_port in self.forwarding_table.items():
                content = json.dumps(self.distance_vector)
                self.send(to_port, Packet(Packet.ROUTING, self.addr, endpoint , content=content))

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors
            for endpoint, port in self.forwarding_table.items():
                content = json.dumps(self.distance_vector)
                self.send(port, Packet(Packet.ROUTING, self.addr, endpoint , content=content))
            pass

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        if not self.debug:
            print(f"""DVrouter(addr={self.addr}
            links={self.links}
            distance_vector = {self.distance_vector}
            forwarding_table={self.forwarding_table}
            neighbors={self.neighbors}))""")
            self.debug = True
        #   NOTE This method is for your own convenience and will not be graded
        return f"DVrouter(addr={self.addr})"
